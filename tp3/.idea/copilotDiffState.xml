<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/org/sims/models/Particle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/sims/models/Particle.java" />
              <option name="originalContent" value="package org.sims.models;&#10;&#10;import org.apache.commons.math3.linear.MatrixUtils;&#10;import org.apache.commons.math3.linear.RealMatrix;&#10;import org.sims.Simulation;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;public class Particle {&#10;    private Vector position;&#10;    private Vector velocity;&#10;    private double radius;&#10;&#10;    public Particle(Vector position, Vector velocity, double radius) {&#10;        this.radius = radius;&#10;        this.position = position;&#10;        this.velocity = velocity;&#10;    }&#10;&#10;    public Vector getVelocity() {&#10;        return velocity;&#10;    }&#10;&#10;    public void setVelocity(Vector velocity) {&#10;        this.velocity = velocity;&#10;    }&#10;&#10;    /**&#10;     * Move particle according to its velocity a delta time&#10;     *&#10;     * @param dt time step&#10;     */&#10;    public void move(double dt) {&#10;        setPosition(this.position.add(this.velocity.mult(dt)));&#10;    }&#10;&#10;    /**&#10;     * Move particle according to its velocity a delta time of 1&#10;     *&#10;     * @see #move(double)&#10;     */&#10;    public void move() {&#10;        move(0.001);&#10;    }&#10;&#10;    public Vector getPosition() {&#10;        return position;&#10;    }&#10;&#10;    public void setPosition(Vector position) {&#10;        this.position = position;&#10;    }&#10;&#10;    public double getRadius() {&#10;        return radius;&#10;    }&#10;&#10;    /**&#10;     * Compute timo of collision of this particle with another particle&#10;     *&#10;     * @param p description of the parameter&#10;     * @return time of collision from now -&gt; infinity if particles dont collide&#10;     */&#10;    public Simulation.Event collisionTime(final Particle p) {&#10;        final double relativeVelocityX = p.velocity.getX() - this.velocity.getX();&#10;        final double relativeVelocityY = p.velocity.getY() - this.velocity.getY();&#10;        final double relativePositionX = p.position.getX() - this.position.getX();&#10;        final double relativePositionY = p.position.getY() - this.position.getY();&#10;        final double sigma = this.radius + p.radius;&#10;&#10;        final Vector relativeVelocity = new Vector(relativeVelocityX, relativeVelocityY);&#10;        final Vector relativePosition = new Vector(relativePositionX, relativePositionY);&#10;&#10;        final double d = Math.pow(relativeVelocity.dot(relativePosition), 2) -&#10;                relativeVelocity.dot(relativeVelocity) *&#10;                        (relativePosition.dot(relativePosition) - sigma * sigma);&#10;&#10;        if (d &lt; 0 || relativeVelocity.dot(relativePosition) &gt;= 0) {&#10;            return new Simulation.Event(this, null, Double.POSITIVE_INFINITY);&#10;        }&#10;&#10;        return new Simulation.Event(this,null, -(relativeVelocity.dot(relativePosition) + Math.sqrt(d)) / relativeVelocity.dot(relativeVelocity));&#10;    }&#10;&#10;    /**&#10;     * Compute timo  of collision with all walls&#10;     *&#10;     * @return smallest collision time&#10;     */&#10;    public Simulation.Event collisionTimeWithWalls(final List&lt;Wall&gt; walls) {&#10;        return new Simulation.Event(this, null, walls.parallelStream().map(w -&gt; w.collidesWith(this)).min(Double::compareTo).orElse(Double.POSITIVE_INFINITY));&#10;    }&#10;&#10;    private static final double MAGIC_NUMBER = 0.09;&#10;&#10;    /**&#10;     * Generates initial list of particles with random positions and radii&#10;     *&#10;     * @param numParticles     number of particles to generate&#10;     * @param startingVelocity initial velocity of particles -&gt; now used as x,y&#10;     *                         components&#10;     * @return true if valid position&#10;     */&#10;    public static List&lt;Particle&gt; generateInitialState(int numParticles, double startingVelocity, double radius) {&#10;        final List&lt;Wall&gt; walls = Wall.generate(0.05);&#10;        final List&lt;Particle&gt; particles = new ArrayList&lt;&gt;(numParticles);&#10;&#10;        for (int i = 0; i &lt; numParticles; i++) {&#10;            boolean generated = false;&#10;            double x, y;&#10;            while (!generated) {&#10;                x = Math.random() * MAGIC_NUMBER;&#10;                y = Math.random() * MAGIC_NUMBER;&#10;                // radius = Math.random() * MAGIC_NUMBER;&#10;&#10;                // TODO random velocity direction??&#10;                final var p = new Particle(new Vector(x, y), new Vector(startingVelocity, startingVelocity), radius);&#10;                if (checkValidPosition(p, walls) &amp;&amp; checkNonOverlap(p, particles)) {&#10;                    generated = true;&#10;                    particles.add(p); // Add the particle to the list&#10;                }&#10;            }&#10;        }&#10;&#10;        if (particles.size() &lt; numParticles) {&#10;            throw new IllegalArgumentException(&quot;Radius too big or too many particles&quot;);&#10;        }&#10;&#10;        return particles;&#10;    }&#10;&#10;    /**&#10;     * Checks if a particle is inside boundaries&#10;     * Assumes particles start in a rectangular area&#10;     *&#10;     * @return true if valid position&#10;     */&#10;    private static boolean checkValidPosition(Particle p, List&lt;Wall&gt; walls) {&#10;        Vector pos = p.getPosition();&#10;        double radius = p.getRadius();&#10;&#10;        // Check if particle center plus radius is within the bounded area formed by walls&#10;        // For a rectangular boundary, we need to ensure the particle doesn't go outside&#10;&#10;        double minX = 0.0, maxX = 0.09;&#10;        double minY = 0.0, maxY = 0.09;&#10;&#10;        System.out.println(&quot;particle: &quot; + p);&#10;        System.out.println(&quot;MinX: &quot; + minX + &quot; MaxX: &quot; + maxX + &quot;MinY:  &quot; + minY + &quot;MaxY:  &quot; + maxY);&#10;        System.out.println(&#10;                &quot;Check X: &quot; + ((pos.getX() - radius &gt;= minX) &amp;&amp;&#10;                        (pos.getX() + radius &lt;= maxX)) + &quot; Check Y: &quot;&#10;                        + ((pos.getY() - radius &gt;= minY) &amp;&amp;&#10;                                (pos.getY() + radius &lt;= maxY)));&#10;&#10;        // Check if particle (considering its radius) is within bounds&#10;        return (pos.getX() - radius &gt;= minX) &amp;&amp;&#10;                (pos.getX() + radius &lt;= maxX) &amp;&amp;&#10;                (pos.getY() - radius &gt;= minY) &amp;&amp;&#10;                (pos.getY() + radius &lt;= maxY);&#10;    }&#10;&#10;    private static boolean checkNonOverlap(Particle p, List&lt;Particle&gt; particles) {&#10;        final Vector pos = p.getPosition();&#10;        final double radius = p.getRadius();&#10;&#10;        for (final var other : particles) {&#10;            final Vector otherPos = other.getPosition();&#10;            final double otherRadius = other.getRadius();&#10;&#10;            // Calculate distance between particle centers&#10;            final double dx = pos.getX() - otherPos.getX();&#10;            final double dy = pos.getY() - otherPos.getY();&#10;            final double distance = Math.sqrt(dx * dx + dy * dy);&#10;&#10;            // Check if distance is less than sum of radii (overlap condition)&#10;            if (distance &lt; radius + otherRadius) {&#10;                return false; // Overlap detected&#10;            }&#10;        }&#10;&#10;        return true; // No overlap&#10;    }&#10;&#10;&#10;&#10;    private static double ct = 1, cn = 1;&#10;    /**&#10;     * Changes velocities of the particles received&#10;     * @param p first particle&#10;     * @param other second particle&#10;     */&#10;    public static void collide(Particle p, Particle other) {&#10;        Vector normalVersor = Vector.subtract(p.getPosition(), other.getPosition());&#10;        Vector xVersor = new Vector(1,0);&#10;        double alpha = Vector.angle(normalVersor, xVersor);    //angle between normal versor of collision and x axis&#10;        double cosAlpha = Math.cos(alpha);&#10;        double sinAlpha = Math.sin(alpha);&#10;        double m11 = (-cn * cosAlpha*cosAlpha) + (ct * sinAlpha*sinAlpha);&#10;        double m12 = -(cn+ct)*sinAlpha*cosAlpha;&#10;        double m21 = m12;&#10;        double m22 = (-cn * sinAlpha*sinAlpha) + (ct * cosAlpha*cosAlpha);&#10;        double[][] m = new double[][]{  {m11, m12},&#10;                                        {m21, m22} };&#10;        RealMatrix collisionOperator = MatrixUtils.createRealMatrix(m);&#10;&#10;        //=======First particle=======&#10;        RealMatrix v1 = MatrixUtils.createRealMatrix(p.getVelocity().toColumnMatrix());&#10;        double[] v1Prime = collisionOperator.multiply(v1).getColumn(0);&#10;        p.setVelocity(new Vector(v1Prime[0], v1Prime[1]));&#10;&#10;        //=======Second particle=====&#10;        RealMatrix v2 = MatrixUtils.createRealMatrix(other.getVelocity().toColumnMatrix());&#10;        double[] v2Prime = collisionOperator.multiply(v2).getColumn(0);&#10;        other.setVelocity(new Vector(v2Prime[0], v2Prime[1]));&#10;    }&#10;&#10;    public static void collide(Particle p, Wall w) {&#10;        if(w.getVertex1().getX()-w.getVertex2().getX()&lt;=0){ //horizontal wall&#10;            p.setVelocity(new Vector(p.getVelocity().getX(), -p.getVelocity().getY()));&#10;        }&#10;        else if(w.getVertex1().getY()-w.getVertex2().getY()&lt;=0){ //vertical wall&#10;            p.setVelocity(new Vector(-p.getVelocity().getX(), p.getVelocity().getY()));&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o)&#10;            return true;&#10;&#10;        if (o == null || !(o instanceof Particle other))&#10;            return false;&#10;&#10;        return Double.compare(other.radius, radius) == 0 &amp;&amp;&#10;                position.equals(other.position) &amp;&amp;&#10;                velocity.equals(other.velocity);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(position, velocity, radius);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return String.format(&quot;%s %s %.14f&quot;, position, velocity, radius);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.sims.models;&#10;&#10;import org.apache.commons.math3.linear.MatrixUtils;&#10;import org.apache.commons.math3.linear.RealMatrix;&#10;import org.sims.Simulation;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Objects;&#10;&#10;public class Particle {&#10;    private Vector position;&#10;    private Vector velocity;&#10;    private double radius;&#10;&#10;    public Particle(Vector position, Vector velocity, double radius) {&#10;        this.radius = radius;&#10;        this.position = position;&#10;        this.velocity = velocity;&#10;    }&#10;&#10;    public Vector getVelocity() {&#10;        return velocity;&#10;    }&#10;&#10;    public void setVelocity(Vector velocity) {&#10;        this.velocity = velocity;&#10;    }&#10;&#10;    /**&#10;     * Move particle according to its velocity a delta time&#10;     *&#10;     * @param dt time step&#10;     */&#10;    public void move(double dt) {&#10;        setPosition(this.position.add(this.velocity.mult(dt)));&#10;    }&#10;&#10;    /**&#10;     * Move particle according to its velocity a delta time of 1&#10;     *&#10;     * @see #move(double)&#10;     */&#10;    public void move() {&#10;        move(0.001);&#10;    }&#10;&#10;    public Vector getPosition() {&#10;        return position;&#10;    }&#10;&#10;    public void setPosition(Vector position) {&#10;        this.position = position;&#10;    }&#10;&#10;    public double getRadius() {&#10;        return radius;&#10;    }&#10;&#10;    /**&#10;     * Compute timo of collision of this particle with another particle&#10;     *&#10;     * @param p description of the parameter&#10;     * @return time of collision from now -&gt; infinity if particles dont collide&#10;     */&#10;    public Simulation.Event collisionTime(final Particle p) {&#10;        final double relativeVelocityX = p.velocity.getX() - this.velocity.getX();&#10;        final double relativeVelocityY = p.velocity.getY() - this.velocity.getY();&#10;        final double relativePositionX = p.position.getX() - this.position.getX();&#10;        final double relativePositionY = p.position.getY() - this.position.getY();&#10;        final double sigma = this.radius + p.radius;&#10;&#10;        final Vector relativeVelocity = new Vector(relativeVelocityX, relativeVelocityY);&#10;        final Vector relativePosition = new Vector(relativePositionX, relativePositionY);&#10;&#10;        final double d = Math.pow(relativeVelocity.dot(relativePosition), 2) -&#10;                relativeVelocity.dot(relativeVelocity) *&#10;                        (relativePosition.dot(relativePosition) - sigma * sigma);&#10;&#10;        if (d &lt; 0 || relativeVelocity.dot(relativePosition) &gt;= 0) {&#10;            return new Simulation.Event(this, null, Double.POSITIVE_INFINITY);&#10;        }&#10;&#10;        return new Simulation.Event(this,null, -(relativeVelocity.dot(relativePosition) + Math.sqrt(d)) / relativeVelocity.dot(relativeVelocity));&#10;    }&#10;&#10;    /**&#10;     * Compute timo  of collision with all walls&#10;     *&#10;     * @return smallest collision time&#10;     */&#10;    public Simulation.Event collisionTimeWithWalls(final List&lt;Wall&gt; walls) {&#10;        return new Simulation.Event(this, null, walls.parallelStream().map(w -&gt; w.collidesWith(this)).min(Double::compareTo).orElse(Double.POSITIVE_INFINITY));&#10;    }&#10;&#10;    private static final double MAGIC_NUMBER = 0.09;&#10;&#10;    /**&#10;     * Generates initial list of particles with random positions and radii&#10;     *&#10;     * @param numParticles     number of particles to generate&#10;     * @param startingVelocity initial velocity of particles -&gt; now used as x,y&#10;     *                         components&#10;     * @return true if valid position&#10;     */&#10;    public static List&lt;Particle&gt; generateInitialState(int numParticles, double startingVelocity, double radius) {&#10;        final List&lt;Wall&gt; walls = Wall.generate(0.05);&#10;        final List&lt;Particle&gt; particles = new ArrayList&lt;&gt;(numParticles);&#10;&#10;        for (int i = 0; i &lt; numParticles; i++) {&#10;            boolean generated = false;&#10;            double x, y;&#10;            while (!generated) {&#10;                x = Math.random() * MAGIC_NUMBER;&#10;                y = Math.random() * MAGIC_NUMBER;&#10;                // radius = Math.random() * MAGIC_NUMBER;&#10;&#10;                // TODO random velocity direction??&#10;                final var p = new Particle(new Vector(x, y), new Vector(startingVelocity, startingVelocity), radius);&#10;                if (checkValidPosition(p, walls) &amp;&amp; checkNonOverlap(p, particles)) {&#10;                    generated = true;&#10;                    particles.add(p); // Add the particle to the list&#10;                }&#10;            }&#10;        }&#10;&#10;        if (particles.size() &lt; numParticles) {&#10;            throw new IllegalArgumentException(&quot;Radius too big or too many particles&quot;);&#10;        }&#10;&#10;        return particles;&#10;    }&#10;&#10;    /**&#10;     * Checks if a particle is inside boundaries&#10;     * Assumes particles start in a rectangular area&#10;     *&#10;     * @return true if valid position&#10;     */&#10;    private static boolean checkValidPosition(Particle p, List&lt;Wall&gt; walls) {&#10;        Vector pos = p.getPosition();&#10;        double radius = p.getRadius();&#10;&#10;        // Check if particle center plus radius is within the bounded area formed by walls&#10;        // For a rectangular boundary, we need to ensure the particle doesn't go outside&#10;&#10;        double minX = 0.0, maxX = 0.09;&#10;        double minY = 0.0, maxY = 0.09;&#10;&#10;        System.out.println(&quot;particle: &quot; + p);&#10;        System.out.println(&quot;MinX: &quot; + minX + &quot; MaxX: &quot; + maxX + &quot;MinY:  &quot; + minY + &quot;MaxY:  &quot; + maxY);&#10;        System.out.println(&#10;                &quot;Check X: &quot; + ((pos.getX() - radius &gt;= minX) &amp;&amp;&#10;                        (pos.getX() + radius &lt;= maxX)) + &quot; Check Y: &quot;&#10;                        + ((pos.getY() - radius &gt;= minY) &amp;&amp;&#10;                                (pos.getY() + radius &lt;= maxY)));&#10;&#10;        // Check if particle (considering its radius) is within bounds&#10;        return (pos.getX() - radius &gt;= minX) &amp;&amp;&#10;                (pos.getX() + radius &lt;= maxX) &amp;&amp;&#10;                (pos.getY() - radius &gt;= minY) &amp;&amp;&#10;                (pos.getY() + radius &lt;= maxY);&#10;    }&#10;&#10;    private static boolean checkNonOverlap(Particle p, List&lt;Particle&gt; particles) {&#10;        final Vector pos = p.getPosition();&#10;        final double radius = p.getRadius();&#10;&#10;        for (final var other : particles) {&#10;            final Vector otherPos = other.getPosition();&#10;            final double otherRadius = other.getRadius();&#10;&#10;            // Calculate distance between particle centers&#10;            final double dx = pos.getX() - otherPos.getX();&#10;            final double dy = pos.getY() - otherPos.getY();&#10;            final double distance = Math.sqrt(dx * dx + dy * dy);&#10;&#10;            // Check if distance is less than sum of radii (overlap condition)&#10;            if (distance &lt; radius + otherRadius) {&#10;                return false; // Overlap detected&#10;            }&#10;        }&#10;&#10;        return true; // No overlap&#10;    }&#10;&#10;&#10;&#10;    private static double ct = 1, cn = 1;&#10;    /**&#10;     * Changes velocities of the particles received&#10;     * @param p first particle&#10;     * @param other second particle&#10;     */&#10;    public static void collide(Particle p, Particle other) {&#10;        Vector normalVersor = Vector.subtract(p.getPosition(), other.getPosition());&#10;        Vector xVersor = new Vector(1,0);&#10;        double alpha = Vector.angle(normalVersor, xVersor);    //angle between normal versor of collision and x axis&#10;        double cosAlpha = Math.cos(alpha);&#10;        double sinAlpha = Math.sin(alpha);&#10;        double m11 = (-cn * cosAlpha*cosAlpha) + (ct * sinAlpha*sinAlpha);&#10;        double m12 = -(cn+ct)*sinAlpha*cosAlpha;&#10;        double m21 = m12;&#10;        double m22 = (-cn * sinAlpha*sinAlpha) + (ct * cosAlpha*cosAlpha);&#10;        double[][] m = new double[][]{  {m11, m12},&#10;                                        {m21, m22} };&#10;        RealMatrix collisionOperator = MatrixUtils.createRealMatrix(m);&#10;&#10;        //=======First particle=======&#10;        RealMatrix v1 = MatrixUtils.createRealMatrix(p.getVelocity().toColumnMatrix());&#10;        double[] v1Prime = collisionOperator.multiply(v1).getColumn(0);&#10;        p.setVelocity(new Vector(v1Prime[0], v1Prime[1]));&#10;&#10;        //=======Second particle=====&#10;        RealMatrix v2 = MatrixUtils.createRealMatrix(other.getVelocity().toColumnMatrix());&#10;        double[] v2Prime = collisionOperator.multiply(v2).getColumn(0);&#10;        other.setVelocity(new Vector(v2Prime[0], v2Prime[1]));&#10;    }&#10;&#10;    public static void collide(Particle p, Wall w) {&#10;        if(w.getVertex1().getX()-w.getVertex2().getX()&lt;=0){ //horizontal wall&#10;            p.setVelocity(new Vector(p.getVelocity().getX(), -p.getVelocity().getY()));&#10;        }&#10;        else if(w.getVertex1().getY()-w.getVertex2().getY()&lt;=0){ //vertical wall&#10;            p.setVelocity(new Vector(-p.getVelocity().getX(), p.getVelocity().getY()));&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o)&#10;            return true;&#10;&#10;        if (o == null || !(o instanceof Particle other))&#10;            return false;&#10;&#10;        return Double.compare(other.radius, radius) == 0 &amp;&amp;&#10;                position.equals(other.position) &amp;&amp;&#10;                velocity.equals(other.velocity);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(position, velocity, radius);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return String.format(&quot;%s %s %.14f&quot;, position, velocity, radius);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>